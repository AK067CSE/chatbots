import streamlit as st
from pathlib import Path
import json
from datetime import datetime
import tempfile
import os
import pandas as pd

from src.advanced_rag import AdvancedRAGSystem
from src.pdf_extractor import PDFExtractor
from src.comparator import DocumentComparator
from src.report_generator import generate_all_reports, DetailedDiscrepancyAnalyzer, AlertGenerator, StructuredDataExtractor
from src.llm_chains import LLMChainOrchestrator, MultiTurnChatChain
from src.config import settings
import json


st.set_page_config(
    page_title="Advanced PDF Analysis Chatbot",
    page_icon="ðŸ“„",
    layout="wide",
    initial_sidebar_state="expanded"
)


def initialize_session():
    if 'rag_system' not in st.session_state:
        st.session_state.rag_system = AdvancedRAGSystem()
    if 'chat_chain' not in st.session_state:
        st.session_state.chat_chain = MultiTurnChatChain()
    if 'llm_orchestrator' not in st.session_state:
        st.session_state.llm_orchestrator = LLMChainOrchestrator()
    if 'uploaded_documents' not in st.session_state:
        st.session_state.uploaded_documents = {}
    if 'extracted_data' not in st.session_state:
        st.session_state.extracted_data = []
    if 'comparison_results' not in st.session_state:
        st.session_state.comparison_results = None
    if 'po_doc' not in st.session_state:
        st.session_state.po_doc = None
    if 'invoice_doc' not in st.session_state:
        st.session_state.invoice_doc = None
    if 'messages' not in st.session_state:
        st.session_state.messages = []


def extract_pdf_content(pdf_file):
    extractor = PDFExtractor()
    
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
        tmp_file.write(pdf_file.read())
        tmp_path = tmp_file.name
    
    try:
        doc = extractor.extract_pdf(Path(tmp_path))
        return doc, None
    except Exception as e:
        return None, str(e)
    finally:
        os.unlink(tmp_path)


def display_document_summary(doc):
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Document Type", doc.metadata.doc_type)
    with col2:
        st.metric("Total Items", len(doc.items))
    with col3:
        st.metric("Grand Total", f"${doc.total:,.2f}")
    
    if doc.items:
        st.subheader("Line Items")
        items_data = []
        for item in doc.items:
            items_data.append({
                "SKU": item.item_no,
                "Description": item.description,
                "Qty": item.quantity,
                "Unit Price": f"${item.unit_price:.2f}",
                "Total": f"${item.total_price:.2f}"
            })
        st.dataframe(items_data, use_container_width=True)
    
    st.subheader("Financial Summary")
    fin_col1, fin_col2, fin_col3, fin_col4 = st.columns(4)
    with fin_col1:
        st.metric("Subtotal", f"${doc.subtotal:,.2f}")
    with fin_col2:
        st.metric("Tax", f"${doc.tax:,.2f}")
    with fin_col3:
        st.metric("Total", f"${doc.total:,.2f}")
    with fin_col4:
        st.metric("Vendor", doc.metadata.vendor_name)


def handle_pdf_upload():
    st.header("ðŸ“¤ Upload PDF Documents")
    
    uploaded_files = st.file_uploader(
        "Upload PDF files (PO or Invoice)",
        type="pdf",
        accept_multiple_files=True,
        key="pdf_uploader"
    )
    
    if uploaded_files:
        col1, col2 = st.columns([1, 1])
        
        with col1:
            if st.button("ðŸ“¥ Process Documents"):
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                for idx, pdf_file in enumerate(uploaded_files):
                    status_text.text(f"Processing {pdf_file.name}...")
                    
                    doc, error = extract_pdf_content(pdf_file)
                    
                    if error:
                        st.error(f"Error processing {pdf_file.name}: {error}")
                    else:
                        doc_id = f"doc_{len(st.session_state.uploaded_documents)}"
                        st.session_state.uploaded_documents[doc_id] = {
                            'filename': pdf_file.name,
                            'document': doc,
                            'timestamp': datetime.now().isoformat()
                        }
                        
                        chunk_count = st.session_state.rag_system.add_document(doc, doc_id)
                        st.session_state.extracted_data.append(doc)
                        
                        st.success(f"âœ“ {pdf_file.name} - {chunk_count} chunks indexed")
                    
                    progress_bar.progress((idx + 1) / len(uploaded_files))
                
                status_text.text("âœ“ Processing complete!")
    
    if st.session_state.uploaded_documents:
        st.subheader("Uploaded Documents")
        for doc_id, doc_info in st.session_state.uploaded_documents.items():
            with st.expander(f"ðŸ“„ {doc_info['filename']}"):
                display_document_summary(doc_info['document'])


def handle_document_comparison():
    if len(st.session_state.extracted_data) >= 2:
        st.header("ðŸ” Document Comparison & Analysis")
        
        po_doc = None
        invoice_doc = None
        
        for doc in st.session_state.extracted_data:
            if 'PURCHASE_ORDER' in doc.metadata.doc_type:
                po_doc = doc
            elif 'PROFORMA_INVOICE' in doc.metadata.doc_type or 'INVOICE' in doc.metadata.doc_type:
                invoice_doc = doc
        
        if po_doc and invoice_doc:
            if st.button("Compare Documents", key="compare_btn"):
                comparator = DocumentComparator()
                comparison = comparator.compare(po_doc, invoice_doc)
                st.session_state.comparison_results = comparison
                st.session_state.po_doc = po_doc
                st.session_state.invoice_doc = invoice_doc
            
            if st.session_state.comparison_results:
                comparison = st.session_state.comparison_results
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Matching Items", comparison.matching_items)
                with col2:
                    st.metric("Discrepancies", comparison.discrepant_items)
                with col3:
                    st.metric("Total Variance", f"${comparison.grand_total_diff:,.2f}")
                with col4:
                    st.metric("Variance %", f"{comparison.grand_total_variance_pct:.2f}%")
                
                tab_summary, tab_quantity, tab_price, tab_alerts, tab_extracted = st.tabs(
                    ["Summary", "Quantity Analysis", "Price Analysis", "Alerts", "Extracted Data"]
                )
                
                with tab_summary:
                    if comparison.discrepancies:
                        st.warning("âš  Discrepancies Found")
                        disc_data = []
                        for disc in comparison.discrepancies:
                            disc_data.append({
                                "Item": disc.item_no,
                                "Description": disc.description,
                                "PO Qty": disc.po_quantity,
                                "Invoice Qty": disc.invoice_quantity,
                                "PO Price": f"${disc.po_unit_price:.2f}",
                                "Invoice Price": f"${disc.invoice_unit_price:.2f}",
                                "Status": disc.status
                            })
                        st.dataframe(disc_data, use_container_width=True)
                    else:
                        st.success("No discrepancies found - documents match!")
                
                with tab_quantity:
                    st.subheader("Quantity Comparison")
                    qty_analysis = DetailedDiscrepancyAnalyzer._analyze_quantities(po_doc, invoice_doc, comparison)
                    qty_df = pd.DataFrame(qty_analysis)
                    st.dataframe(qty_df, use_container_width=True)
                
                with tab_price:
                    st.subheader("Price Analysis")
                    if comparison.discrepancies:
                        price_analysis = DetailedDiscrepancyAnalyzer._analyze_prices(comparison)
                        price_df = pd.DataFrame(price_analysis)
                        st.dataframe(price_df, use_container_width=True)
                    else:
                        st.info("No price discrepancies")
                
                with tab_alerts:
                    st.subheader("Automated Alerts & Recommendations")
                    alerts = AlertGenerator.generate_alerts(comparison)
                    if alerts:
                        for alert in alerts:
                            alert_level = alert["level"]
                            if alert_level == "CRITICAL":
                                st.error(f"ðŸš¨ {alert['type']}: {alert['message']}")
                                st.info(f"Recommendation: {alert['recommendation']}")
                            else:
                                st.warning(f"âš  {alert['type']}: {alert['message']}")
                                st.info(f"Recommendation: {alert['recommendation']}")
                    else:
                        st.success("No alerts - documents approved!")
                
                with tab_extracted:
                    st.subheader("Extracted Document Data")
                    col1, col2 = st.columns(2)
                    with col1:
                        st.write("**Purchase Order**")
                        po_data = StructuredDataExtractor.extract_document_data(po_doc)
                        st.json(po_data)
                    with col2:
                        st.write("**Proforma Invoice**")
                        pi_data = StructuredDataExtractor.extract_document_data(invoice_doc)
                        st.json(pi_data)
                
                st.divider()
                st.subheader("Generate & Download Reports")
                if st.button("Generate All Reports"):
                    with st.spinner("Generating reports..."):
                        report_paths = generate_all_reports(comparison, settings.REPORTS_DIR, po_doc, invoice_doc)
                        st.success("Reports generated!")
                        
                        col1, col2, col3 = st.columns(3)
                        for fmt, path in list(report_paths.items())[:3]:
                            with open(path, 'rb') as f:
                                with col1 if fmt == 'json' else (col2 if fmt == 'csv' else col3):
                                    st.download_button(
                                        label=f"Download {fmt.upper()}",
                                        data=f.read(),
                                        file_name=Path(path).name,
                                        mime="application/octet-stream"
                                    )
                        
                        col1, col2, col3 = st.columns(3)
                        remaining = list(report_paths.items())[3:]
                        for i, (fmt, path) in enumerate(remaining):
                            with open(path, 'rb') as f:
                                with [col1, col2, col3][i % 3]:
                                    st.download_button(
                                        label=f"Download {fmt.upper()}",
                                        data=f.read(),
                                        file_name=Path(path).name,
                                        mime="application/octet-stream"
                                    )


def handle_intelligent_chat():
    st.header("ðŸ’¬ Intelligent Document Chat")
    
    if not st.session_state.uploaded_documents:
        st.info("Please upload PDF documents first to start chatting.")
        return
    
    st.subheader("Document Q&A")
    
    query = st.text_input("Ask a question about your documents:", key="chat_input")
    
    if query:
        with st.spinner("Searching documents and generating response..."):
            retrieved_results = st.session_state.rag_system.retrieve(query, top_k=5, use_fusion=True)
            
            context_text = "\n\n".join([r['text'] for r in retrieved_results[:3]])
            
            result = st.session_state.llm_orchestrator.process_query(query, context_text)
            
            st.session_state.messages.append({
                "role": "user",
                "content": query,
                "timestamp": datetime.now().isoformat()
            })
            st.session_state.messages.append({
                "role": "assistant",
                "content": result['response'],
                "timestamp": datetime.now().isoformat()
            })
    
    if st.session_state.messages:
        st.subheader("Conversation History")
        for msg in st.session_state.messages:
            if msg['role'] == 'user':
                st.write(f"**You:** {msg['content']}")
            else:
                st.write(f"**Assistant:** {msg['content']}")
    
    if st.button("Clear Chat History"):
        st.session_state.messages = []
        st.rerun()


def handle_advanced_analysis():
    st.header("ðŸ”¬ Advanced Analysis")
    
    if not st.session_state.comparison_results:
        st.info("Please compare documents first.")
        return
    
    if st.button("Generate Detailed Analysis"):
        with st.spinner("Analyzing documents..."):
            analysis = st.session_state.llm_orchestrator.analyze_full_comparison(
                {
                    'po_total': st.session_state.comparison_results.po_total,
                    'invoice_total': st.session_state.comparison_results.invoice_total,
                    'discrepancies': len(st.session_state.comparison_results.discrepancies)
                },
                [doc.raw_text[:500] for doc in st.session_state.extracted_data]
            )
            
            st.subheader("Analysis Report")
            st.write(analysis['report'])
            
            st.subheader("Document Summary")
            st.write(analysis['summary'])


def main():
    initialize_session()
    
    st.title("ðŸ“Š Advanced PDF Analysis & Chat Bot")
    st.markdown("*Extract, Compare, Analyze, and Chat with your PDF documents using Advanced RAG*")
    
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "ðŸ“¤ Upload", "ðŸ“‹ Compare", "ðŸ’¬ Chat", "ðŸ”¬ Analysis", "ðŸ“Š Summary"
    ])
    
    with tab1:
        handle_pdf_upload()
    
    with tab2:
        handle_document_comparison()
    
    with tab3:
        handle_intelligent_chat()
    
    with tab4:
        handle_advanced_analysis()
    
    with tab5:
        st.header("System Summary")
        
        rag_summary = st.session_state.rag_system.get_summary()
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Documents Indexed", rag_summary['documents'])
        with col2:
            st.metric("Total Chunks", rag_summary['chunks'])
        with col3:
            st.metric("Retrieval Methods", len(rag_summary['retrieval_methods']))
        
        st.subheader("Retrieval Methods Available")
        for method in rag_summary['retrieval_methods']:
            st.write(f"âœ“ {method}")
        
        st.subheader("Session Info")
        st.write(f"Messages: {len(st.session_state.messages)}")
        st.write(f"Uploaded Documents: {len(st.session_state.uploaded_documents)}")


if __name__ == "__main__":
    main()

from pathlib import Path
from typing import Dict
import json
from src.config import settings
from src.pdf_extractor import extract_all_pdfs, ExtractedDocument
from src.comparator import compare_po_with_invoice
from src.report_generator import generate_all_reports
try:
    from src.rag_system import initialize_rag_system
except Exception as e:
    from src.rag_system_simple import initialize_rag_system

try:
    from src.chatbot import initialize_chatbot
except Exception:
    from src.chatbot_simple import initialize_simple_chatbot as initialize_chatbot


class PDFAnalysisOrchestrator:
    def __init__(self):
        self.data_dir = settings.DATA_DIR
        self.reports_dir = settings.REPORTS_DIR
        self.reports_dir.mkdir(parents=True, exist_ok=True)
        
        self.extracted_documents = {}
        self.po_doc = None
        self.invoice_doc = None
        self.comparison_result = None
        self.rag_system = None
        self.analysis_agent = None
        self.chatbot = None
    
    def run_complete_pipeline(self) -> Dict:
        print("\n" + "="*60)
        print("PDF ANALYSIS PIPELINE - COMPLETE WORKFLOW")
        print("="*60 + "\n")
        
        print("[STEP 1/6] Extracting PDF documents...")
        self.extract_documents()
        
        print("[STEP 2/6] Comparing PO with Invoice...")
        self.compare_documents()
        
        print("[STEP 3/6] Generating reports...")
        self.generate_reports()
        
        print("[STEP 4/6] Initializing RAG system...")
        self.initialize_rag()
        
        print("[STEP 5/6] Setting up analysis agent...")
        self.setup_agent()
        
        print("[STEP 6/6] Initializing chatbot...")
        self.setup_chatbot()
        
        return self.get_pipeline_summary()
    
    def extract_documents(self) -> Dict[str, ExtractedDocument]:
        self.extracted_documents = extract_all_pdfs(self.data_dir)
        
        for name, doc in self.extracted_documents.items():
            print(f"  [OK] Extracted {name}")
            print(f"    - Type: {doc.metadata.doc_type}")
            print(f"    - Items: {len(doc.items)}")
            print(f"    - Total: ${doc.total:.2f}")
        
        return self.extracted_documents
    
    def compare_documents(self):
        self.po_doc = None
        self.invoice_doc = None
        
        for name, doc in self.extracted_documents.items():
            if 'PURCHASE_ORDER' in doc.metadata.doc_type:
                self.po_doc = doc
            elif 'PROFORMA_INVOICE' in doc.metadata.doc_type:
                self.invoice_doc = doc
        
        if self.po_doc and self.invoice_doc:
            self.comparison_result = compare_po_with_invoice(self.po_doc, self.invoice_doc)
            print(f"  [OK] Comparison completed")
            print(f"    - Discrepancies found: {len(self.comparison_result.discrepancies)}")
            print(f"    - Total difference: ${self.comparison_result.grand_total_diff:.2f}")
        else:
            print("  [ERR] Could not find both PO and Invoice documents")
    
    def generate_reports(self) -> Dict[str, str]:
        if not self.comparison_result:
            print("  [ERR] No comparison result to report")
            return {}
        
        report_paths = generate_all_reports(self.comparison_result, self.reports_dir, self.po_doc, self.invoice_doc)
        
        for format_type, path in report_paths.items():
            print(f"  [OK] Generated {format_type.upper()} report: {Path(path).name}")
        
        return report_paths
    
    def initialize_rag(self):
        self.rag_system = initialize_rag_system(settings.CHROMA_DB_PATH)
        print(f"  [OK] RAG system initialized at {settings.CHROMA_DB_PATH}")
        
        for name, doc in self.extracted_documents.items():
            self.rag_system.add_document(doc, name)
        
        print(f"  [OK] Added {len(self.extracted_documents)} documents to RAG system")
    
    def setup_agent(self):
        if not self.rag_system:
            print("  [ERR] RAG system not initialized")
            return
        
        try:
            from src.agent_rag import create_analysis_agent as create_agent
            self.analysis_agent = create_agent(self.rag_system)
            print("  [OK] Analysis agent ready")
        except Exception as e:
            print(f"  [WARN] Analysis agent setup skipped: {e}")
    
    def setup_chatbot(self):
        if not self.rag_system:
            print("  [ERR] RAG system not initialized")
            return
        
        try:
            self.chatbot = initialize_chatbot(self.rag_system)
            print("  [OK] Chatbot initialized and ready")
        except Exception as e:
            print(f"  [WARN] Using simplified chatbot: {e}")
            try:
                from src.chatbot_simple import initialize_simple_chatbot
                self.chatbot = initialize_simple_chatbot(self.rag_system)
                print("  [OK] Simplified chatbot initialized")
            except Exception as e2:
                print(f"  [ERR] Chatbot initialization failed: {e2}")
    
    def analyze_with_agent(self, query: str) -> Dict:
        if not self.analysis_agent:
            return {'error': 'Agent not initialized'}
        
        return self.analysis_agent.analyze_query(query)
    
    def chat(self, user_query: str) -> Dict:
        if not self.chatbot:
            return {'error': 'Chatbot not initialized'}
        
        return self.chatbot.chat(user_query)
    
    def get_pipeline_summary(self) -> Dict:
        return {
            'status': 'complete',
            'documents_extracted': len(self.extracted_documents),
            'discrepancies_found': len(self.comparison_result.discrepancies) if self.comparison_result else 0,
            'reports_generated': 4,
            'rag_ready': self.rag_system is not None,
            'agent_ready': self.analysis_agent is not None,
            'chatbot_ready': self.chatbot is not None,
            'reports_directory': str(self.reports_dir),
            'rag_db_path': str(settings.CHROMA_DB_PATH)
        }
    
    def print_pipeline_summary(self):
        summary = self.get_pipeline_summary()
        print("\n" + "="*60)
        print("PIPELINE SUMMARY")
        print("="*60)
        for key, value in summary.items():
            print(f"{key}: {value}")
        print("="*60 + "\n")
    
    def interactive_analysis(self):
        print("\n" + "="*60)
        print("INTERACTIVE ANALYSIS MODE")
        print("="*60)
        print("Type 'help' for commands, 'exit' to quit\n")
        
        while True:
            try:
                user_input = input("Query> ").strip()
                
                if not user_input:
                    continue
                
                if user_input.lower() == 'exit':
                    print("Exiting...")
                    break
                
                if user_input.lower() == 'help':
                    print("""
COMMANDS:
- Any natural language question about the documents
- 'compare' - Show comparison details
- 'discrepancies' - List all discrepancies
- 'summary' - Show full summary
- 'help' - Show this help
- 'exit' - Exit the program
""")
                    continue
                
                if user_input.lower() == 'compare':
                    if self.comparison_result:
                        print(self.comparison_result.summary)
                    continue
                
                if user_input.lower() == 'discrepancies':
                    if self.comparison_result:
                        for d in self.comparison_result.discrepancies[:5]:
                            print(f"- {d.description}: {d.status}")
                    continue
                
                if user_input.lower() == 'summary':
                    self.print_pipeline_summary()
                    continue
                
                response = self.chat(user_input)
                print(f"\nAssistant: {response['response']}\n")
                
            except KeyboardInterrupt:
                print("\n\nInterrupted.")
                break
            except Exception as e:
                print(f"Error: {str(e)}")


def main():
    orchestrator = PDFAnalysisOrchestrator()
    
    summary = orchestrator.run_complete_pipeline()
    orchestrator.print_pipeline_summary()
    
    return orchestrator


if __name__ == "__main__":
    main()


import json
import csv
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime
import pandas as pd
from src.comparator import DocumentComparison, ItemDiscrepancy
from src.pdf_extractor import ExtractedDocument


class StructuredDataExtractor:
    @staticmethod
    def extract_document_data(doc: ExtractedDocument) -> Dict[str, Any]:
        return {
            "document_type": doc.metadata.doc_type,
            "document_id": doc.metadata.document_id,
            "date": doc.metadata.date,
            "vendor": doc.metadata.vendor_name,
            "customer": doc.metadata.customer_name,
            "items": [
                {
                    "sku": item.item_no,
                    "description": item.description,
                    "unit": item.unit,
                    "quantity": item.quantity,
                    "unit_price": round(item.unit_price, 2),
                    "line_total": round(item.total_price, 2)
                }
                for item in doc.items
            ],
            "summary": {
                "subtotal": round(doc.subtotal, 2),
                "tax": round(doc.tax, 2),
                "grand_total": round(doc.total, 2)
            },
            "extraction_timestamp": datetime.now().isoformat()
        }
    
    @staticmethod
    def generate_extraction_json(po_doc: ExtractedDocument, pi_doc: ExtractedDocument, output_dir: Path) -> str:
        extraction_data = {
            "purchase_order": StructuredDataExtractor.extract_document_data(po_doc),
            "proforma_invoice": StructuredDataExtractor.extract_document_data(pi_doc)
        }
        
        output_path = output_dir / "extracted_data.json"
        with open(output_path, 'w') as f:
            json.dump(extraction_data, f, indent=2)
        
        return str(output_path)


class DetailedDiscrepancyAnalyzer:
    @staticmethod
    def analyze_all_items(po_doc: ExtractedDocument, pi_doc: ExtractedDocument, comparison: DocumentComparison) -> Dict[str, Any]:
        analysis = {
            "quantity_analysis": DetailedDiscrepancyAnalyzer._analyze_quantities(po_doc, pi_doc, comparison),
            "price_analysis": DetailedDiscrepancyAnalyzer._analyze_prices(comparison),
            "totals_analysis": DetailedDiscrepancyAnalyzer._analyze_totals(comparison),
            "mismatches_summary": DetailedDiscrepancyAnalyzer._summarize_mismatches(comparison)
        }
        return analysis
    
    @staticmethod
    def _analyze_quantities(po_doc, pi_doc, comparison):
        items = []
        po_items_map = {item.item_no: item for item in po_doc.items}
        pi_items_map = {item.item_no: item for item in pi_doc.items}
        
        all_skus = set(po_items_map.keys()) | set(pi_items_map.keys())
        
        for sku in sorted(all_skus):
            po_qty = po_items_map.get(sku, None)
            pi_qty = pi_items_map.get(sku, None)
            
            po_quantity = po_qty.quantity if po_qty else 0
            pi_quantity = pi_qty.quantity if pi_qty else 0
            diff = pi_quantity - po_quantity
            
            items.append({
                "sku": sku,
                "description": (po_qty.description if po_qty else pi_qty.description) if (po_qty or pi_qty) else "Unknown",
                "po_quantity": po_quantity,
                "pi_quantity": pi_quantity,
                "difference": diff,
                "status": "MATCH" if diff == 0 else "MISMATCH"
            })
        
        return items
    
    @staticmethod
    def _analyze_prices(comparison):
        items = []
        for d in comparison.discrepancies:
            items.append({
                "sku": d.item_no,
                "description": d.description,
                "po_unit_price": round(d.po_unit_price, 2),
                "pi_unit_price": round(d.invoice_unit_price, 2),
                "unit_price_diff": round(d.price_diff, 2),
                "po_line_total": round(d.po_total, 2),
                "pi_line_total": round(d.invoice_total, 2),
                "line_total_diff": round(d.total_diff, 2),
                "status": "PRICE_MISMATCH" if d.price_variance_pct != 0 else d.status
            })
        return items
    
    @staticmethod
    def _analyze_totals(comparison):
        return {
            "po_subtotal": round(comparison.po_subtotal, 2),
            "pi_subtotal": round(comparison.invoice_subtotal, 2),
            "subtotal_difference": round(comparison.subtotal_diff, 2),
            "subtotal_variance_pct": round(comparison.subtotal_variance_pct, 2),
            "po_grand_total": round(comparison.po_total, 2),
            "pi_grand_total": round(comparison.invoice_total, 2),
            "grand_total_difference": round(comparison.grand_total_diff, 2),
            "grand_total_variance_pct": round(comparison.grand_total_variance_pct, 2)
        }
    
    @staticmethod
    def _summarize_mismatches(comparison):
        mismatches = []
        for d in comparison.discrepancies:
            mismatch_types = []
            
            if d.quantity_variance_pct != 0:
                mismatch_types.append("Quantity")
            if d.price_variance_pct != 0:
                mismatch_types.append("Unit Price")
            if d.total_diff != 0 and d.quantity_variance_pct == 0:
                mismatch_types.append("Line Total")
            
            mismatches.append({
                "sku": d.item_no,
                "issue_type": " + ".join(mismatch_types) if mismatch_types else "Other",
                "description": d.description,
                "severity": DetailedDiscrepancyAnalyzer._get_severity(d),
                "details": {
                    "quantity_diff": d.quantity_diff if d.quantity_variance_pct != 0 else None,
                    "price_diff": round(d.price_diff, 2) if d.price_variance_pct != 0 else None,
                    "total_diff": round(d.total_diff, 2)
                }
            })
        
        return mismatches
    
    @staticmethod
    def _get_severity(d):
        if abs(d.quantity_variance_pct) > 50 or abs(d.price_variance_pct) > 50:
            return "CRITICAL"
        elif abs(d.quantity_variance_pct) > 10 or abs(d.price_variance_pct) > 10:
            return "HIGH"
        else:
            return "MEDIUM"


class AlertGenerator:
    @staticmethod
    def generate_alerts(comparison: DocumentComparison) -> List[Dict[str, Any]]:
        alerts = []
        
        variance_pct = abs(comparison.grand_total_variance_pct)
        
        if variance_pct > 5:
            alerts.append({
                "level": "CRITICAL" if variance_pct > 10 else "HIGH",
                "type": "TOTAL_VALUE_MISMATCH",
                "message": f"Invoice total exceeds PO by AED {comparison.grand_total_diff:.2f} ({variance_pct:.2f}%)",
                "recommendation": "Manual review required before payment processing"
            })
        
        if comparison.discrepant_items > 0:
            alerts.append({
                "level": "HIGH",
                "type": "ITEM_DISCREPANCIES",
                "message": f"{comparison.discrepant_items} item(s) with discrepancies detected",
                "recommendation": "Review line-by-line comparison"
            })
        
        quantity_mismatches = sum(1 for d in comparison.discrepancies if d.quantity_variance_pct != 0)
        if quantity_mismatches > 0:
            alerts.append({
                "level": "HIGH",
                "type": "QUANTITY_MISMATCH",
                "message": f"Quantity mismatch on {quantity_mismatches} item(s)",
                "recommendation": "Verify with supplier or delivery documentation"
            })
        
        price_mismatches = sum(1 for d in comparison.discrepancies if d.price_variance_pct != 0)
        if price_mismatches > 0:
            alerts.append({
                "level": "HIGH",
                "type": "PRICE_MISMATCH",
                "message": f"Price mismatch on {price_mismatches} item(s)",
                "recommendation": "Verify contract pricing and check for unauthorized changes"
            })
        
        critical_items = sum(1 for d in comparison.discrepancies if abs(d.price_variance_pct) > 20 or abs(d.quantity_variance_pct) > 20)
        if critical_items > 0:
            alerts.append({
                "level": "CRITICAL",
                "type": "CRITICAL_VARIANCE",
                "message": f"{critical_items} item(s) with variance > 20%",
                "recommendation": "Escalate for immediate management review"
            })
        
        return alerts


class ReportGenerator:
    def __init__(self, output_dir: Path):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def generate_json_report(self, comparison: DocumentComparison, filename: str = "comparison_report.json") -> str:
        report_data = {
            'metadata': {
                'po_id': comparison.po_doc_id,
                'invoice_id': comparison.invoice_doc_id,
            },
            'summary_statistics': {
                'total_items_in_po': comparison.total_items_po,
                'total_items_in_invoice': comparison.total_items_invoice,
                'items_matching': comparison.matching_items,
                'items_with_discrepancies': comparison.discrepant_items,
                'po_total_value': round(comparison.po_total, 2),
                'invoice_total_value': round(comparison.invoice_total, 2),
                'value_difference': round(comparison.grand_total_diff, 2),
                'variance_percentage': round(comparison.grand_total_variance_pct, 2),
            },
            'discrepancies': [
                {
                    'item_number': d.item_no,
                    'description': d.description,
                    'quantity': {
                        'po': d.po_quantity,
                        'invoice': d.invoice_quantity,
                        'difference': round(d.quantity_diff, 2),
                        'variance_percent': round(d.quantity_variance_pct, 2)
                    },
                    'unit_price': {
                        'po': round(d.po_unit_price, 2),
                        'invoice': round(d.invoice_unit_price, 2),
                        'difference': round(d.price_diff, 2),
                        'variance_percent': round(d.price_variance_pct, 2)
                    },
                    'total_price': {
                        'po': round(d.po_total, 2),
                        'invoice': round(d.invoice_total, 2),
                        'difference': round(d.total_diff, 2),
                    },
                    'discrepancy_type': d.status,
                    'severity': self._calculate_severity(d)
                }
                for d in comparison.discrepancies
            ],
            'summary_text': comparison.summary
        }
        
        output_path = self.output_dir / filename
        with open(output_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        return str(output_path)
    
    def generate_csv_report(self, comparison: DocumentComparison, filename: str = "comparison_report.csv") -> str:
        output_path = self.output_dir / filename
        
        with open(output_path, 'w', newline='') as f:
            fieldnames = [
                'Item_Number',
                'Description',
                'PO_Quantity',
                'Invoice_Quantity',
                'Quantity_Difference',
                'Quantity_Variance_%',
                'PO_Unit_Price',
                'Invoice_Unit_Price',
                'Price_Difference',
                'Price_Variance_%',
                'PO_Total',
                'Invoice_Total',
                'Total_Difference',
                'Discrepancy_Type',
                'Severity'
            ]
            
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            
            for d in comparison.discrepancies:
                writer.writerow({
                    'Item_Number': d.item_no,
                    'Description': d.description,
                    'PO_Quantity': d.po_quantity,
                    'Invoice_Quantity': d.invoice_quantity,
                    'Quantity_Difference': round(d.quantity_diff, 2),
                    'Quantity_Variance_%': round(d.quantity_variance_pct, 2),
                    'PO_Unit_Price': round(d.po_unit_price, 2),
                    'Invoice_Unit_Price': round(d.invoice_unit_price, 2),
                    'Price_Difference': round(d.price_diff, 2),
                    'Price_Variance_%': round(d.price_variance_pct, 2),
                    'PO_Total': round(d.po_total, 2),
                    'Invoice_Total': round(d.invoice_total, 2),
                    'Total_Difference': round(d.total_diff, 2),
                    'Discrepancy_Type': d.status,
                    'Severity': self._calculate_severity(d)
                })
        
        return str(output_path)
    
    def generate_excel_report(self, comparison: DocumentComparison, filename: str = "comparison_report.xlsx") -> str:
        output_path = self.output_dir / filename
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            summary_df = pd.DataFrame([{
                'PO_ID': comparison.po_doc_id,
                'Invoice_ID': comparison.invoice_doc_id,
                'Total_Items_PO': comparison.total_items_po,
                'Total_Items_Invoice': comparison.total_items_invoice,
                'Matching_Items': comparison.matching_items,
                'Discrepant_Items': comparison.discrepant_items,
                'PO_Total': round(comparison.po_total, 2),
                'Invoice_Total': round(comparison.invoice_total, 2),
                'Difference': round(comparison.grand_total_diff, 2),
                'Variance_%': round(comparison.grand_total_variance_pct, 2)
            }])
            summary_df.to_excel(writer, sheet_name='Summary', index=False)
            
            discrepancy_data = []
            for d in comparison.discrepancies:
                discrepancy_data.append({
                    'Item_Number': d.item_no,
                    'Description': d.description,
                    'PO_Qty': d.po_quantity,
                    'Invoice_Qty': d.invoice_quantity,
                    'Qty_Diff': round(d.quantity_diff, 2),
                    'Qty_Variance_%': round(d.quantity_variance_pct, 2),
                    'PO_Price': round(d.po_unit_price, 2),
                    'Invoice_Price': round(d.invoice_unit_price, 2),
                    'Price_Diff': round(d.price_diff, 2),
                    'Price_Variance_%': round(d.price_variance_pct, 2),
                    'PO_Total': round(d.po_total, 2),
                    'Invoice_Total': round(d.invoice_total, 2),
                    'Total_Diff': round(d.total_diff, 2),
                    'Type': d.status,
                    'Severity': self._calculate_severity(d)
                })
            
            discrepancy_df = pd.DataFrame(discrepancy_data)
            discrepancy_df.to_excel(writer, sheet_name='Discrepancies', index=False)
        
        return str(output_path)
    
    def generate_html_report(self, comparison: DocumentComparison, filename: str = "comparison_report.html") -> str:
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>PO vs Invoice Comparison Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        .summary {{ background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background-color: #4CAF50; color: white; }}
        tr:nth-child(even) {{ background-color: #f2f2f2; }}
        .critical {{ background-color: #ffcccc; }}
        .warning {{ background-color: #ffffcc; }}
        .info {{ background-color: #ccf2ff; }}
    </style>
</head>
<body>
    <h1>Purchase Order vs Invoice Comparison Report</h1>
    
    <div class="summary">
        <h2>Comparison Summary</h2>
        <p><strong>PO ID:</strong> {comparison.po_doc_id}</p>
        <p><strong>Invoice ID:</strong> {comparison.invoice_doc_id}</p>
        <p><strong>Total Items in PO:</strong> {comparison.total_items_po}</p>
        <p><strong>Total Items in Invoice:</strong> {comparison.total_items_invoice}</p>
        <p><strong>Matching Items:</strong> {comparison.matching_items}</p>
        <p><strong>Items with Discrepancies:</strong> {comparison.discrepant_items}</p>
        <p><strong>PO Total Value:</strong> ${comparison.po_total:.2f}</p>
        <p><strong>Invoice Total Value:</strong> ${comparison.invoice_total:.2f}</p>
        <p><strong>Difference:</strong> ${comparison.grand_total_diff:.2f} ({comparison.grand_total_variance_pct:.2f}%)</p>
    </div>
    
    <h2>Discrepancies Found</h2>
    <table>
        <tr>
            <th>Item</th>
            <th>Description</th>
            <th>Quantity (PO)</th>
            <th>Quantity (Invoice)</th>
            <th>Unit Price (PO)</th>
            <th>Unit Price (Invoice)</th>
            <th>Total (PO)</th>
            <th>Total (Invoice)</th>
            <th>Type</th>
            <th>Severity</th>
        </tr>
"""
        
        for d in comparison.discrepancies:
            severity = self._calculate_severity(d)
            severity_class = 'critical' if severity == 'CRITICAL' else 'warning' if severity == 'HIGH' else 'info'
            
            html_content += f"""
        <tr class="{severity_class}">
            <td>{d.item_no}</td>
            <td>{d.description}</td>
            <td>{d.po_quantity}</td>
            <td>{d.invoice_quantity}</td>
            <td>${d.po_unit_price:.2f}</td>
            <td>${d.invoice_unit_price:.2f}</td>
            <td>${d.po_total:.2f}</td>
            <td>${d.invoice_total:.2f}</td>
            <td>{d.status}</td>
            <td>{severity}</td>
        </tr>
"""
        
        html_content += """
    </table>
</body>
</html>
"""
        
        output_path = self.output_dir / filename
        with open(output_path, 'w') as f:
            f.write(html_content)
        
        return str(output_path)
    
    def _calculate_severity(self, discrepancy: ItemDiscrepancy) -> str:
        if abs(discrepancy.quantity_variance_pct) > 50 or abs(discrepancy.price_variance_pct) > 50:
            return "CRITICAL"
        elif abs(discrepancy.quantity_variance_pct) > 10 or abs(discrepancy.price_variance_pct) > 10:
            return "HIGH"
        elif "MISSING" in discrepancy.status or "EXTRA" in discrepancy.status:
            return "HIGH"
        else:
            return "MEDIUM"
    
    def generate_detailed_analysis_json(self, po_doc: ExtractedDocument, pi_doc: ExtractedDocument, comparison: DocumentComparison, filename: str = "detailed_analysis.json") -> str:
        detailed_analysis = DetailedDiscrepancyAnalyzer.analyze_all_items(po_doc, pi_doc, comparison)
        alerts = AlertGenerator.generate_alerts(comparison)
        
        analysis_report = {
            "metadata": {
                "po_id": comparison.po_doc_id,
                "invoice_id": comparison.invoice_doc_id,
                "generated_at": datetime.now().isoformat(),
                "total_items_po": comparison.total_items_po,
                "total_items_invoice": comparison.total_items_invoice,
                "matching_items": comparison.matching_items,
                "discrepant_items": comparison.discrepant_items
            },
            "quantity_analysis": detailed_analysis["quantity_analysis"],
            "price_analysis": detailed_analysis["price_analysis"],
            "totals_analysis": detailed_analysis["totals_analysis"],
            "mismatches_summary": detailed_analysis["mismatches_summary"],
            "alerts": alerts
        }
        
        output_path = self.output_dir / filename
        with open(output_path, 'w') as f:
            json.dump(analysis_report, f, indent=2)
        
        return str(output_path)
    
    def generate_comprehensive_excel(self, po_doc: ExtractedDocument, pi_doc: ExtractedDocument, comparison: DocumentComparison, filename: str = "comprehensive_analysis.xlsx") -> str:
        detailed_analysis = DetailedDiscrepancyAnalyzer.analyze_all_items(po_doc, pi_doc, comparison)
        alerts = AlertGenerator.generate_alerts(comparison)
        
        output_path = self.output_dir / filename
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            summary_df = pd.DataFrame([{
                'PO_ID': comparison.po_doc_id,
                'Invoice_ID': comparison.invoice_doc_id,
                'Total_Items_PO': comparison.total_items_po,
                'Total_Items_Invoice': comparison.total_items_invoice,
                'Matching_Items': comparison.matching_items,
                'Discrepant_Items': comparison.discrepant_items,
                'PO_Total': round(comparison.po_total, 2),
                'Invoice_Total': round(comparison.invoice_total, 2),
                'Difference': round(comparison.grand_total_diff, 2),
                'Variance_%': round(comparison.grand_total_variance_pct, 2)
            }])
            summary_df.to_excel(writer, sheet_name='Summary', index=False)
            
            qty_df = pd.DataFrame(detailed_analysis["quantity_analysis"])
            qty_df.to_excel(writer, sheet_name='Quantity_Analysis', index=False)
            
            price_df = pd.DataFrame(detailed_analysis["price_analysis"])
            price_df.to_excel(writer, sheet_name='Price_Analysis', index=False)
            
            totals_data = [detailed_analysis["totals_analysis"]]
            totals_df = pd.DataFrame(totals_data)
            totals_df.to_excel(writer, sheet_name='Totals_Summary', index=False)
            
            mismatches_df = pd.DataFrame(detailed_analysis["mismatches_summary"])
            mismatches_df.to_excel(writer, sheet_name='Mismatches', index=False)
            
            alerts_df = pd.DataFrame(alerts)
            alerts_df.to_excel(writer, sheet_name='Alerts', index=False)
        
        return str(output_path)
    
    def generate_alerts_report(self, comparison: DocumentComparison, filename: str = "alerts_report.json") -> str:
        alerts = AlertGenerator.generate_alerts(comparison)
        
        output_path = self.output_dir / filename
        with open(output_path, 'w') as f:
            json.dump({"alerts": alerts, "generated_at": datetime.now().isoformat()}, f, indent=2)
        
        return str(output_path)


def generate_all_reports(comparison: DocumentComparison, output_dir: Path, po_doc: ExtractedDocument = None, pi_doc: ExtractedDocument = None):
    generator = ReportGenerator(output_dir)
    
    reports = {
        'json': generator.generate_json_report(comparison),
        'csv': generator.generate_csv_report(comparison),
        'excel': generator.generate_excel_report(comparison),
        'html': generator.generate_html_report(comparison),
        'alerts': generator.generate_alerts_report(comparison)
    }
    
    if po_doc and pi_doc:
        reports['extracted_data'] = StructuredDataExtractor.generate_extraction_json(po_doc, pi_doc, output_dir)
        reports['detailed_analysis'] = generator.generate_detailed_analysis_json(po_doc, pi_doc, comparison)
        reports['comprehensive_excel'] = generator.generate_comprehensive_excel(po_doc, pi_doc, comparison)
    
    return reports

whats the problem with these than 